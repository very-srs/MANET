#!/bin/bash
exec > >(tee /boot/firmware/firstrun.log) 2>&1
set -x
echo "=== firstrun.sh starting at $(date) ==="

echo "Disabling first-boot wizard and creating user..."
chown root:systemd-journal /var/log/journal
chmod 2755 /var/log/journal
systemctl restart systemd-journald

# Stop and disable the userconfig wizard service
systemctl disable userconfig.service 2>/dev/null || true
systemctl stop userconfig.service 2>/dev/null || true

# Remove wizard autostart files
rm -f /etc/xdg/autostart/piwiz.desktop 2>/dev/null || true
rm -f /usr/lib/raspberrypi-sys-mods/firstboot 2>/dev/null || true

# Create the radio user with proper groups
if ! id -u radio > /dev/null 2>&1; then
    echo "Creating user 'radio'..."
    useradd -m -s /bin/bash -G sudo,adm,dialout,cdrom,audio,video,plugdev,games,users,input,netdev,gpio,i2c,spi radio
    echo "radio:radio" | chpasswd
    
    # Set up SSH directory
    mkdir -p /home/radio/.ssh
    chmod 700 /home/radio/.ssh
    chown -R radio:radio /home/radio/.ssh
    
    echo "User 'radio' created successfully"
fi

# Enable SSH service
systemctl enable ssh
systemctl start ssh

echo "User setup complete - proceeding with provisioning..."

# Don't wait for network - just create a service to run after network is ready
echo "Creating post-network provisioning service..."

cat > /usr/local/bin/provision-mesh.sh << 'PROVISIONEOF'
#!/bin/bash
exec > >(tee -a /boot/firmware/provision.log) 2>&1
set -x
echo "=== provision-mesh-node.sh starting at $(date) ==="

REG=US
# Calculate unique hostname from MAC address
HOST_MAC=$(ip a | grep -A1 $(networkctl | grep -v bat | awk '/ether/ {print $2}' | head -1) \
   | awk '/ether/ {print $2}' | cut -d':' -f 5-6 | sed 's/://g')

echo "Detected HOST_MAC: $HOST_MAC"
echo "Using regulatory region: $REG"



# NOW we can safely wait for network - boot is complete
echo "Waiting for internet connectivity..."
TIMEOUT=300
ELAPSED=0
while [ $ELAPSED -lt $TIMEOUT ]; do
    if ping -c 1 -W 2 8.8.8.8 > /dev/null 2>&1; then
        echo "Internet connectivity confirmed!"
        break
    fi
    echo "Waiting for internet... (${ELAPSED}s)"
    sleep 5
    ELAPSED=$((ELAPSED + 5))
done

if [ $ELAPSED -ge $TIMEOUT ]; then
    echo "ERROR: No internet after ${TIMEOUT}s"
    exit 1
fi

cd /root


if [ "__HARDWARE_MODEL__" = "rpi5" ]; then
        echo "Applying RPi 5 specific settings..."

        #this will be a github release file for a univeral URL
        wget -q --no-check-certificate https://10.30.1.1:8081/data/rpi5-0.3.tar -O /root/rpi5-0.3.tar || {
                echo "ERROR: Failed to download rpi5 package"
                exit 1
        }
	tar -xf /root/rpi5-0.3.tar -C /

        # The rpi5 is using an SD card and may need to be resized
        # Check if filesystem is nearly full (indicating small partition)
        USAGE_PERCENT=$(df / | tail -1 | awk '{print $5}' | tr -d '%')
        echo "Root filesystem is ${USAGE_PERCENT}% full"

        # If filesystem is >80% full, partition is too small - expand
        if [ $USAGE_PERCENT -gt 80 ]; then
            echo "Filesystem nearly full, expanding partition..."

            # Expand the partition
            raspi-config --expand-rootfs

            # Resize the filesystem to fill the new partition
            resize2fs /dev/mmcblk0p2

            echo "Expansion complete"
#           systemctl reboot
        else
        echo "Filesystem has room (${USAGE_PERCENT}%), skipping expansion."
        fi
        touch /var/lib/expand-root-done
elif [ "__HARDWARE_MODEL__" = "rpi4" ]; then
        echo "Applying RPi 4 specific settings..."
        wget -q --no-check-certificate https://10.30.1.1:8081/data/rpi4-0.3.tar  -O /root/rpi4-0.3.tar || {
                echo "ERROR: Failed to download rpi4 package"
                exit 1
        }
        tar -xf /root/rpi4-0.3.tar -C /
fi

#
#  Setup base system
#


# get the sources up to date and install packages
echo -n "Updating system packages..."
apt update  > /dev/null 2>&1
echo -n "."
apt upgrade -y > /dev/null 2>&1
echo -n "."

# Remove the question about the iperf daemon during apt install
echo "iperf3 iperf3/start_daemon boolean true" | debconf-set-selections

# Install packages for this system
apt install -y ipcalc nmap lshw tcpdump net-tools nftables wireless-tools iperf3\
        radvd bridge-utils firmware-mediatek libnss-mdns syncthing networkd-dispatcher\
        libgps-dev libcap-dev mumble-server screen arping bc jq git \
        python3-protobuf unzip chrony build-essential systemd-resolved
echo "Done"

apt remove yq > /dev/null 2>&1

# Download and install Go yq
wget -q https://github.com/mikefarah/yq/releases/latest/download/yq_linux_arm64 -O /usr/bin/yq
chmod +x /usr/bin/yq




echo "Disabling APT timers for automatic updates"
systemctl disable apt-daily.timer 2>&1
systemctl disable apt-daily-upgrade.timer 2>&1

# This is hanging on boot
systemctl mask dev-zram0.device

# Get firmware
cd /root/morse-firmware
make install
cd /root

#load modules at boot
cat <<- EOF > /etc/modules-load.d/morse.conf
        mac80211
        cfg80211
        crc7
        morse
        dot11ah
EOF
echo "Morse Micro 802.11ah system installed"
echo "batman-adv" > /etc/modules-load.d/batman.conf
echo "i2c_dev" > /etc/modules-load.d/i2c_dev.conf

# Switch to the kernel with manet related patches and drivers
dpkg -i /root/linux-image-6.6.78-manet+_*.deb || true
dpkg -i /root/linux-headers-6.6.78-manet+_*.deb || true

# Copy kernel to boot partition
cp /boot/vmlinuz-6.6.78-manet+ /boot/firmware/kernel8.img
cp /boot/vmlinuz-6.6.78-manet+ /boot/firmware/
cp /boot/System.map-6.6.78-manet+ /boot/firmware/
cp /boot/config-6.6.78-manet+ /boot/firmware/

# This isn't needed for the manet kernel and causes errors
chmod -x /etc/kernel/postinst.d/initramfs-tools

# disable the default wpa_supplicant service
systemctl disable wpa_supplicant.service > /dev/null 2>&1

#set hostname, make unique by ethernet mac addr (last 4)
hostnamectl hostname radio-$HOST_MAC
echo "Hostname set"

#set regulatory region as US
echo options cfg80211 ieee80211_regdom=$REG > /etc/modprobe.d/wifi-regdom.conf
echo "Set wifi regulatory domain to $REG"

#turn on packet forwarding
cat <<- EOF > /etc/sysctl.d/99-mesh.conf
        # IPv4 forwarding for mesh
        net.ipv4.ip_forward=1
        net.ipv4.conf.all.forwarding=1
        net.ipv4.conf.default.forwarding=1

        # IPv4 multicast forwarding
        net.ipv4.conf.all.mc_forwarding=1
        net.ipv4.conf.default.mc_forwarding=1
        net.ipv4.conf.bat0.mc_forwarding=1
        net.ipv4.conf.br0.mc_forwarding=1

        # IPv6 forwarding for mesh
        net.ipv6.conf.all.forwarding=1
        net.ipv6.conf.default.forwarding=1

        # IPv6 multicast forwarding
        net.ipv6.conf.all.mc_forwarding=1
        net.ipv6.conf.default.mc_forwarding=1
        net.ipv6.conf.bat0.mc_forwarding=1
        net.ipv6.conf.br0.mc_forwarding=1

        # Increase multicast route cache for large mesh
        net.ipv4.route.max_size=16384
        net.ipv6.route.max_size=16384

        # Optional: Increase ARP cache for many nodes
        net.ipv4.neigh.default.gc_thresh1=1024
        net.ipv4.neigh.default.gc_thresh2=2048
        net.ipv4.neigh.default.gc_thresh3=4096
EOF


#
#  Create the non wifi interfaces
#
cat <<- EOF > /etc/systemd/network/10-bat0.network
        [Match]
        Name=bat0

        [Network]
        Bridge=br0
        LinkLocalAddressing=ipv6
        IPv6Token=eui64
        IPv6PrivacyExtensions=no
EOF

# The bridge br0 is the main interface for the mesh node
cat <<-EOF > /etc/systemd/network/10-br0-bridge.netdev
        [NetDev]
        Name=br0
        Kind=bridge

        [Bridge]
        MulticastSnooping=true
        MulticastQuerier=true
EOF

# br0 will get a slaac ipv6 address
cat <<-EOF > /etc/systemd/network/20-br0-bridge.network
        [Match]
        Name=br0

        [Network]
        DHCP=no
        LinkLocalAddressing=ipv6
        IPv6AcceptRA=yes
        MulticastDNS=yes

        [Link]
        RequiredForOnline=no
EOF

#stop other interfaces from doing multicast dns, trim down network chatter
cat <<- EOF > /etc/systemd/network/90-default-no-mdns.network
        [Match]
        Name=!br0

        [Network]
        LLMNR=no
        MulticastDNS=no
EOF

#set ethernet links for DHCP as a default setup
for LAN in `networkctl | awk '/ether/ {print $2}'`; do
	M=`ip link show $LAN | awk '/ether/ {print $2}'`
	cat <<- EOF > /etc/systemd/network/10-$LAN.network
		[Match]
		MACAddress=$M

		[Network]
		DHCP=yes
		LinkLocalAddressing=no
		IPv6AcceptRA=no

		[DHCPv4]
		UseDomains=true
	EOF

done
echo "Ethernet config added"


#
# Configure and enable system services
#

echo "Configuring nftables for IPv4 NAT gateway"
cat <<- EOF > /etc/nftables.conf
        #!/usr/sbin/nft -f

        # Flush the old ruleset to start clean
        flush ruleset
        table inet filter {
          # The INPUT chain handles traffic destined for the node itself.
          chain input {
            type filter hook input priority 0; policy drop;
            ct state {established, related} accept
            ct state invalid drop
            iifname "lo" accept
            # Accept ALL traffic coming from the trusted mesh interface.
            iifname "br0" accept
            iifname "bat0" accept
            iifname "end0" tcp dport 22 accept
          }
          chain forward {
            type filter hook forward priority 0; policy drop;

            # Allow traffic from the trusted mesh to be forwarded
            # out to the internet via the Ethernet port.
            iifname "br0" oifname "end0" accept

            # Allow the return traffic from the internet back to the mesh.
            iifname "end0" oifname "br0" ct state established, related accept
          }
          chain output {
            type filter hook output priority 0; policy accept;
          }
        }

        table ip nat {
          chain postrouting {
            type nat hook postrouting priority 100;
            oifname "end0" masquerade
          }
        }
EOF

echo "Setting up router advertisements"
# Configure router advertisements for slaac on ipv6
# The announced ipv6 prefix with be where all the nodes
# auto configure their addresses to be local to each other
#
# The two files are for when the node is a client
# ( AdvDefaultLifetime 0 ) vs when it advertises itself as
# a gateway ( AdvDefaultLifetime 600 ).  A networkd-dispatcher
# script does the swap
cat <<-EOF > /etc/radvd-mesh.conf
        interface br0
        {
          AdvSendAdvert on;
          AdvDefaultLifetime 0;
          prefix fd01:ed20:ecb4:0::/64  {
            AdvOnLink on;
            AdvAutonomous on;
            AdvRouterAddr off;
          };
        };
EOF

cat <<- EOF > /etc/radvd-gateway.conf
        interface br0 {
          AdvSendAdvert on;
          AdvDefaultLifetime 600;
          prefix fd01:ed20:ecb4:0::/64  {
            AdvOnLink on;
            AdvAutonomous on;
          };
        };
EOF

# Default to mesh config
cp /etc/radvd-mesh.conf /etc/radvd.conf

# make radvd wait for bat0 to be up
mkdir -p /etc/systemd/system/radvd.service.d/
cat <<- EOF > /etc/systemd/system/radvd.service.d/override.conf
        [Unit]
        After=batman-enslave.service
        Wants=batman-enslave.service

        [Service]
        ExecStartPre=/bin/sleep 5
EOF

systemctl enable radvd


# Attempt to sync network time at boot
# Uses data from Alfred to look for any NTP servers (a gw that has
# sync'd its time from the internet) on the mesh.  It picks the
# one with the best transmission quality, does a time sync with it,
# and then disables chrony to prevent excess network traffic
cat <<- EOF > /etc/systemd/system/one-shot-time-sync.service
        [Unit]
        Description=One-Shot Mesh Time Synchronization
        # This must run after the mesh is fully up and the manager has started.
        After=node-manager.service
        Wants=node-manager.service

        [Service]
        Type=oneshot
        ExecStart=/usr/local/bin/one-shot-time-sync.sh

        [Install]
        WantedBy=multi-user.target
EOF
# this will be enabled by radio-setup.sh
#systemctl enable one-shot-time-sync.service

# Config for the active gateway acting as a mesh NTP server
cat <<- EOF > /etc/chrony/chrony-server.conf
        # Use public NTP servers from the internet.
        pool pool.ntp.org iburst
        driftfile /var/lib/chrony/chrony.drift
        makestep 1.0 3
        # Allow clients from our private mesh prefix.
	allow fd01:ed20:ecb4::/64
        # Serve time even if internet connection is lost.
        local stratum 10
EOF

# Config used ONLY to test external NTP connectivity
cat <<- EOF > /etc/chrony/chrony-test.conf
        # Use public NTP servers from the internet.
        pool pool.ntp.org iburst
        driftfile /var/lib/chrony/chrony.drift
        makestep 1.0 3
        # Do NOT allow any clients - this is just a test config.
        deny all
EOF

# Set the default configuration to be a client.  Allows chrony to start
echo "Setting default NTP mode to offline"
cat <<- EOF > /etc/chrony-default.conf
        # This configuration file makes chronyd start but remain offline
        # until explicitly told to sync via chronyc.
        driftfile /var/lib/chrony/chrony.drift
        makestep 1.0 3
        offline
        deny all
EOF
cp /etc/chrony-default.conf /etc/chrony.conf
systemctl enable chrony.service

# Set br0 to be the wait online interface, avoids boot delay
mkdir -p /etc/systemd/system/systemd-networkd-wait-online.service.d/
cat <<- EOF > /etc/systemd/system/systemd-networkd-wait-online.service.d/override.conf
        [Service]
        ExecStart=
        ExecStart=/lib/systemd/systemd-networkd-wait-online --interface=br0
EOF
# But let's try not using it unless something else enables it
systemctl disable systemd-networkd-wait-online.service

# Disable netplan, networkd will do the networking
mkdir -p /etc/netplan
rm -f /etc/netplan/*
cat <<- EOF > /etc/netplan/99-disable-netplan.yaml
        # This file tells Netplan to do nothing.
        network:
        version: 2
        renderer: networkd
EOF
echo "Netplan disabled, will use networkd instead"

cat <<- EOF > /etc/systemd/resolved.conf
        [Resolve]
        LLMNR=no
        MulticastDNS=no
        DNSStubListener=yes
        Cache=yes
EOF

# Old issue, but useful to avoid any hung mesh node so leaving this in
cat <<- EOF > /etc/sysctl.d/90-kernelpanic-reboot.conf
        kernel.panic = 10
        kernel.panic_on_oops = 1
EOF

echo "Disabling default chrony networkd-dispatcher script"
rm -f /usr/lib/NetworkManager/dispatcher.d/*

# Install optional service selections
if [ "__INSTALL_MUMBLE__" = "y" ]; then
        #make mumble server ini changes
        sed -i '/ice="tcp -h 127.0.0.1 -p 6502"/s/^#//g' /etc/mumble-server.ini
        sed -i 's/icesecretwrite/;icesecretwrite/g' /etc/mumble-server.ini
        service mumble-server restart
        grep -m 1 SuperUser /var/log/mumble-server/mumble-server.log > /root/mumble_pw
fi

# install mediaMTX server
if [ "__INSTALL_MEDIAMTX__" = "y" ]; then
    echo "Installing MediaMTX"
        cd /tmp
        wget -q https://github.com/bluenviron/mediamtx/releases/download/v1.15.3/mediamtx_v1.15.3_linux_arm64.tar.gz
        gzip -d mediamtx_v1.15.3_linux_arm64.tar.gz
        tar -xf mediamtx_v1.15.3_linux_arm64.tar
        groupadd --system mediamtx
        useradd --system -g mediamtx -d /opt/mediamtx -s /sbin/nologin mediamtx
        mkdir /etc/mediamtx && chown mediamtx:mediamtx /etc/mediamtx
        mkdir -p /opt/mediamtx
        cp mediamtx /opt/mediamtx/
        chmod +x /opt/mediamtx/mediamtx
        cp mediamtx.yml /etc/mediamtx/

	cat <<- EOF > /etc/systemd/system/mediamtx.service
		[Unit]
		Description=MediaMTX RTSP/RTMP/WebRTC Server
		After=network.target

		[Service]
		User=mediamtx
		Group=mediamtx
		WorkingDirectory=/opt/mediamtx
		ExecStart=/opt/mediamtx/mediamtx /etc/mediamtx/mediamtx.yml
#               Restart=on-failure
#               RestartSec=5

		[Install]
		WantedBy=multi-user.target
	EOF
fi

echo "Setting radio-setup.sh to run at next reboot"
#set up the second provisioning script to run at boot
cat <<- EOF > /etc/systemd/system/radio-setup-run-once.service
        [Unit]
        Description=Run radio setup script once after reboot
        After=network-online.target multi-user.target
        Wants=network-online.target

        [Service]
        Type=oneshot
        ExecStart=/usr/local/bin/radio-setup.sh
        ExecStartPre=/bin/sleep 10
        RemainAfterExit=no

        [Install]
        WantedBy=multi-user.target
EOF
systemctl enable radio-setup-run-once.service


echo "Disabling old network managers"
systemctl stop dhcpcd
systemctl disable dhcpcd
systemctl stop NetworkManager
systemctl disable NetworkManager
systemctl mask NetworkManager

echo "Enabling systemd-networkd and systemd-resolved"
systemctl enable systemd-networkd
systemctl enable systemd-resolved

# Force systemd-resolved to be the DNS provider
ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf

#write out the config selections for future use
echo "mesh_key=__LAN_SAE_KEY__" > /etc/mesh.conf
echo "mesh_ssid=__LAN_SSID__" >> /etc/mesh.conf
echo "ipv4_network=__LAN_CIDR_BLOCK__"  >> /etc/mesh.conf
echo "mumble=__INSTALL_MUMBLE__" >> /etc/mesh.conf
echo "mtx=__INSTALL_MEDIAMTX__" >> /etc/mesh.conf
echo "acs=__AUTO_CHANNEL__" >> /etc/mesh.conf


systemctl disable mesh-provision

echo "=== Provisioning complete at $(date) ==="
echo "=== Rebooting to apply changes ==="
reboot

PROVISIONEOF

chmod +x /usr/local/bin/*

# Create systemd service to run the provisioning AFTER network is ready
cat > /etc/systemd/system/mesh-provision.service << 'EOF'
[Unit]
Description=Provision Mesh Node After Network
After=network-online.target systemd-networkd.service
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/provision-mesh.sh
RemainAfterExit=yes
StandardOutput=journal+console
StandardError=journal+console

[Install]
WantedBy=multi-user.target
EOF


systemctl daemon-reload
systemctl enable mesh-provision.service

rm /etc/ssh/sshd_config.d/*
echo "=== firstrun.sh complete - provisioning will continue after reboot ==="
echo "=== firstrun.sh exiting at $(date) ==="
