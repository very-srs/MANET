#!/bin/bash
# Redirect all output to a log file we can check later
exec > >(tee /boot/firmware/firstrun.log) 2>&1
set -x  # Print each command before executing
echo "=== firstrun.sh starting at $(date) ==="#
#  This script is placed onto a raspberry pi by rpi-imager
#  It is responsible for bootstrapping a freshly imaged device
#  at first boot.  It will install packages, place configuration
#  files, switch to the MANET kernel, and prep the device for a
#  final setup after another reboot (after adding drivers and
#  firmware for the network devices)
#

#wifi region
REG=US

# used for determining a unique hostname
HOST_MAC=$(ip a | grep -A1 `networkctl | grep -v bat | awk '/ether/ {print $2}'`\
   | awk '/ether/ {print $2}' | cut -d':' -f 5-6 | sed 's/://g')


echo "Waiting for systemd-networkd to start..."
TIMEOUT=60
ELAPSED=0

while [ $ELAPSED -lt $TIMEOUT ]; do
    if systemctl is-active --quiet systemd-networkd; then
        echo "systemd-networkd is running!"
        break
    fi
    echo "systemd-networkd not ready yet... (${ELAPSED}s)"
    sleep 2
    ELAPSED=$((ELAPSED + 2))
done

if ! systemctl is-active --quiet systemd-networkd; then
    echo "WARNING: systemd-networkd did not start after ${TIMEOUT}s"
    echo "Attempting to start it manually..."
    systemctl start systemd-networkd
    sleep 5
fi

# Now wait for the ethernet interface to get an IP
echo "Waiting for ethernet interface to come up..."
TIMEOUT=120
ELAPSED=0

while [ $ELAPSED -lt $TIMEOUT ]; do
    # Check if we have a non-loopback IPv4 address
    if ip -4 addr show | grep -q "inet.*scope global"; then
        IP=$(ip -4 addr show | awk '/inet.*scope global/ {print $2; exit}')
        echo "Got IP address: $IP"
        break
    fi
    echo "Waiting for IP address... (${ELAPSED}s)"
    sleep 3
    ELAPSED=$((ELAPSED + 3))
done

# Finally test internet
echo "Testing internet connectivity..."
ELAPSED=0
TIMEOUT=60
while [ $ELAPSED -lt $TIMEOUT ]; do
    if ping -c 1 -W 2 8.8.8.8 > /dev/null 2>&1; then
        echo "Internet connectivity confirmed!"
        break
    fi
    echo "Waiting for internet... (${ELAPSED}s)"
    sleep 3
    ELAPSED=$((ELAPSED + 3))
done

# Download and unpack the various config files and packages needed
cd /root
if [ "__HARDWARE_MODEL__" = "rpi5" ]; then
	echo "Applying RPi 5 specific settings..."

	#this will be a github release file for a univeral URL
	wget -q http://10.30.1.1:8081/data/rpi5-0.3.tar -O /root/rpi5-0.3.tar || {
		echo "ERROR: Failed to download rpi5 package"
		exit 1
	}
	# The rpi5 is using an SD card and may need to be resized
	# Check if filesystem is nearly full (indicating small partition)
	USAGE_PERCENT=$(df / | tail -1 | awk '{print $5}' | tr -d '%')
	echo "Root filesystem is ${USAGE_PERCENT}% full"

	# If filesystem is >80% full, partition is too small - expand
	if [ $USAGE_PERCENT -gt 80 ]; then
	    echo "Filesystem nearly full, expanding partition..."

	    # Expand the partition
	    raspi-config --expand-rootfs

	    # Resize the filesystem to fill the new partition
	    resize2fs /dev/mmcblk0p2

	    echo "Expansion complete"
#	    systemctl reboot
	else
    	echo "Filesystem has room (${USAGE_PERCENT}%), skipping expansion."
	fi
	touch /var/lib/expand-root-done
elif [ "__HARDWARE_MODEL__" = "rpi4" ]; then
	echo "Applying RPi 4 specific settings..."
	wget -q http://10.30.1.1:8081/data/rpi4-0.3.tar	 -O /root/rpi4-0.3.tar || {
        	echo "ERROR: Failed to download rpi4 package"
		exit 1
	}
	tar -xvf /root/rpi4-0.3.tar -C /
fi



#
#  Setup base system
#


# get the sources up to date and install packages
echo -n "Updating system packages..."
apt update  > /dev/null 2>&1
echo -n "."
apt upgrade -y > /dev/null 2>&1
echo -n "."

# Remove the question about the iperf daemon during apt install
echo "iperf3 iperf3/start_daemon boolean true" | debconf-set-selections

# Install packages for this system
apt install -y ipcalc nmap lshw tcpdump net-tools nftables wireless-tools iperf3\
	radvd bridge-utils firmware-mediatek libnss-mdns syncthing networkd-dispatcher\
	libgps-dev libcap-dev mumble-server screen arping bc jq git \
	python3-protobuf unzip chrony build-essential 
echo "Done"

apt remove yq > /dev/null 2>&1

# Download and install Go yq
wget -q https://github.com/mikefarah/yq/releases/latest/download/yq_linux_arm64 -O /usr/bin/yq
chmod +x /usr/bin/yq




echo "Disabling APT timers for automatic updates"
systemctl disable apt-daily.timer 2>&1
systemctl disable apt-daily-upgrade.timer 2>&1

# This is hanging on boot
systemctl mask dev-zram0.device

# Get firmware
cd /root/morse-firmware
make install
cd /root

#load modules at boot
cat <<- EOF > /etc/modules-load.d/morse.conf
	mac80211
	cfg80211
	crc7
	morse
	dot11ah
EOF
echo "Morse Micro 802.11ah system installed"
echo "batman-adv" > /etc/modules-load.d/batman.conf
echo "i2c_dev" > /etc/modules-load.d/i2c_dev.conf

# Switch to the kernel with manet related patches and drivers
dpkg -i /root/linux-image-6.6.78-manet+_*.deb || true
dpkg -i /root/linux-headers-6.6.78-manet+_*.deb || true

# Copy kernel to boot partition 
cp /boot/vmlinuz-6.6.78-manet+ /boot/firmware/kernel8.img
cp /boot/vmlinuz-6.6.78-manet+ /boot/firmware/
cp /boot/System.map-6.6.78-manet+ /boot/firmware/
cp /boot/config-6.6.78-manet+ /boot/firmware/

# This isn't needed for the manet kernel and causes errors
chmod -x /etc/kernel/postinst.d/initramfs-tools

# disable the default wpa_supplicant service
systemctl disable wpa_supplicant.service > /dev/null 2>&1

#set hostname, make unique by ethernet mac addr (last 4)
hostnamectl hostname radio-$HOST_MAC
echo "Hostname set"

#set regulatory region as US
echo options cfg80211 ieee80211_regdom=$REG > /etc/modprobe.d/wifi-regdom.conf
echo "Set wifi regulatory domain to $REG"

#turn on packet forwarding
cat <<- EOF > /etc/sysctl.d/99-mesh.conf
	# IPv4 forwarding for mesh
	net.ipv4.ip_forward=1
	net.ipv4.conf.all.forwarding=1
	net.ipv4.conf.default.forwarding=1

	# IPv4 multicast forwarding
	net.ipv4.conf.all.mc_forwarding=1
	net.ipv4.conf.default.mc_forwarding=1
	net.ipv4.conf.bat0.mc_forwarding=1
	net.ipv4.conf.br0.mc_forwarding=1

	# IPv6 forwarding for mesh
	net.ipv6.conf.all.forwarding=1
	net.ipv6.conf.default.forwarding=1

	# IPv6 multicast forwarding
	net.ipv6.conf.all.mc_forwarding=1
	net.ipv6.conf.default.mc_forwarding=1
	net.ipv6.conf.bat0.mc_forwarding=1
	net.ipv6.conf.br0.mc_forwarding=1

	# Increase multicast route cache for large mesh
	net.ipv4.route.max_size=16384
	net.ipv6.route.max_size=16384

	# Optional: Increase ARP cache for many nodes
	net.ipv4.neigh.default.gc_thresh1=1024
	net.ipv4.neigh.default.gc_thresh2=2048
	net.ipv4.neigh.default.gc_thresh3=4096
EOF


#
#  Create the non wifi interfaces
#
cat <<- EOF > /etc/systemd/network/10-bat0.network
	[Match]
	Name=bat0

	[Network]
	Bridge=br0
	LinkLocalAddressing=ipv6
	IPv6Token=eui64
	IPv6PrivacyExtensions=no
EOF

# The bridge br0 is the main interface for the mesh node
cat <<-EOF > /etc/systemd/network/10-br0-bridge.netdev
	[NetDev]
	Name=br0
	Kind=bridge

	[Bridge]
	MulticastSnooping=true
	MulticastQuerier=true
EOF

# br0 will get a slaac ipv6 address
cat <<-EOF > /etc/systemd/network/20-br0-bridge.network
	[Match]
	Name=br0

	[Network]
	DHCP=no
	LinkLocalAddressing=ipv6
	IPv6AcceptRA=yes
	MulticastDNS=yes

	[Link]
	RequiredForOnline=no
EOF

#stop other interfaces from doing multicast dns, trim down network chatter
cat <<- EOF > /etc/systemd/network/90-default-no-mdns.network
	[Match]
	Name=!br0

	[Network]
	LLMNR=no
	MulticastDNS=no
EOF

#set ethernet links for DHCP as a default setup
for LAN in `networkctl | awk '/ether/ {print $2}'`; do
	M=`ip link show $LAN | awk '/ether/ {print $2}'`
	cat <<- EOF > /etc/systemd/network/10-$LAN.network
		[Match]
		MACAddress=$M

		[Network]
		DHCP=yes
		LinkLocalAddressing=no
		IPv6AcceptRA=no

		[DHCPv4]
		UseDomains=true
	EOF

done
echo "Ethernet config added"


#
# Configure and enable system services
#

echo "Configuring nftables for IPv4 NAT gateway"
cat <<- EOF > /etc/nftables.conf
	#!/usr/sbin/nft -f

	# Flush the old ruleset to start clean
	flush ruleset
	table inet filter {
	  # The INPUT chain handles traffic destined for the node itself.
	  chain input {
	    type filter hook input priority 0; policy drop;
	    ct state {established, related} accept
	    ct state invalid drop
	    iifname "lo" accept
	    # Accept ALL traffic coming from the trusted mesh interface.
	    iifname "br0" accept
	    iifname "bat0" accept
	    iifname "end0" tcp dport 22 accept
	  }
	  chain forward {
	    type filter hook forward priority 0; policy drop;

	    # Allow traffic from the trusted mesh to be forwarded
	    # out to the internet via the Ethernet port.
	    iifname "br0" oifname "end0" accept

	    # Allow the return traffic from the internet back to the mesh.
	    iifname "end0" oifname "br0" ct state established, related accept
	  }
	  chain output {
	    type filter hook output priority 0; policy accept;
	  }
	}

	table ip nat {
	  chain postrouting {
	    type nat hook postrouting priority 100;
	    oifname "end0" masquerade
	  }
	}
EOF

echo "Setting up router advertisements"
# Configure router advertisements for slaac on ipv6
# The announced ipv6 prefix with be where all the nodes
# auto configure their addresses to be local to each other
#
# The two files are for when the node is a client
# ( AdvDefaultLifetime 0 ) vs when it advertises itself as
# a gateway ( AdvDefaultLifetime 600 ).  A networkd-dispatcher
# script does the swap
cat <<-EOF > /etc/radvd-mesh.conf
	interface br0
	{
	  AdvSendAdvert on;
	  AdvDefaultLifetime 0;
	  prefix fd01:ed20:ecb4:0::/64  {
	    AdvOnLink on;
	    AdvAutonomous on;
	    AdvRouterAddr off;
	  };
	};
EOF

cat <<- EOF > /etc/radvd-gateway.conf
	interface br0 {
	  AdvSendAdvert on;
	  AdvDefaultLifetime 600;
	  prefix fd01:ed20:ecb4:0::/64  {
	    AdvOnLink on;
	    AdvAutonomous on;
	  };
	};
EOF

# Default to mesh config
cp /etc/radvd-mesh.conf /etc/radvd.conf

# make radvd wait for bat0 to be up
mkdir -p /etc/systemd/system/radvd.service.d/
cat <<- EOF > /etc/systemd/system/radvd.service.d/override.conf
	[Unit]
	After=batman-enslave.service
	Wants=batman-enslave.service

	[Service]
	ExecStartPre=/bin/sleep 5
EOF

systemctl enable radvd


# Attempt to sync network time at boot
# Uses data from Alfred to look for any NTP servers (a gw that has
# sync'd its time from the internet) on the mesh.  It picks the
# one with the best transmission quality, does a time sync with it,
# and then disables chrony to prevent excess network traffic
cat <<- EOF > /etc/systemd/system/one-shot-time-sync.service
	[Unit]
	Description=One-Shot Mesh Time Synchronization
	# This must run after the mesh is fully up and the manager has started.
	After=node-manager.service
	Wants=node-manager.service

	[Service]
	Type=oneshot
	ExecStart=/usr/local/bin/one-shot-time-sync.sh

	[Install]
	WantedBy=multi-user.target
EOF
# this will be enabled by radio-setup.sh
#systemctl enable one-shot-time-sync.service

# Config for the active gateway acting as a mesh NTP server
cat <<- EOF > /etc/chrony/chrony-server.conf
	# Use public NTP servers from the internet.
	pool pool.ntp.org iburst
	driftfile /var/lib/chrony/chrony.drift
	makestep 1.0 3
	# Allow clients from our private mesh prefix.
	allow fd5a:1<0xC2><0xB6><0xC2><0xB6>::/64
	# Serve time even if internet connection is lost.
	local stratum 10
EOF

# Config used ONLY to test external NTP connectivity
cat <<- EOF > /etc/chrony/chrony-test.conf
	# Use public NTP servers from the internet.
	pool pool.ntp.org iburst
	driftfile /var/lib/chrony/chrony.drift
	makestep 1.0 3
	# Do NOT allow any clients - this is just a test config.
	deny all
EOF

# Set the default configuration to be a client.  Allows chrony to start
echo "Setting default NTP mode to offline"
cat <<- EOF > /etc/chrony-default.conf
	# This configuration file makes chronyd start but remain offline
	# until explicitly told to sync via chronyc.
	driftfile /var/lib/chrony/chrony.drift
	makestep 1.0 3
	offline
	deny all
EOF
cp /etc/chrony-default.conf /etc/chrony.conf
systemctl enable chrony.service

# Set br0 to be the wait online interface, avoids boot delay
mkdir -p /etc/systemd/system/systemd-networkd-wait-online.service.d/
cat <<- EOF > /etc/systemd/system/systemd-networkd-wait-online.service.d/override.conf
	[Service]
	ExecStart=
	ExecStart=/lib/systemd/systemd-networkd-wait-online --interface=br0
EOF
# But let's try not using it unless something else enables it
systemctl disable systemd-networkd-wait-online.service

# Disable netplan, networkd will do the networking
mkdir -p /etc/netplan
rm -f /etc/netplan/*
cat <<- EOF > /etc/netplan/99-disable-netplan.yaml
	# This file tells Netplan to do nothing.
	network:
	version: 2
	renderer: networkd
EOF
echo "Netplan disabled, will use networkd instead"

cat <<- EOF > /etc/systemd/resolved.conf
	[Resolve]
	LLMNR=no
	MulticastDNS=no
	DNSStubListener=yes
	Cache=yes
EOF

# Old issue, but useful to avoid any hung mesh node so leaving this in
cat <<- EOF > /etc/sysctl.d/90-kernelpanic-reboot.conf
	kernel.panic = 10
	kernel.panic_on_oops = 1
EOF

echo "Disabling default chrony networkd-dispatcher script"
rm -f /usr/lib/NetworkManager/dispatcher.d/*

# Install optional service selections
if [ "__INSTALL_MUMBLE__" = "y" ]; then
	#make mumble server ini changes
	sed -i '/ice="tcp -h 127.0.0.1 -p 6502"/s/^#//g' /etc/mumble-server.ini
	sed -i 's/icesecretwrite/;icesecretwrite/g' /etc/mumble-server.ini
	service mumble-server restart
	grep -m 1 SuperUser /var/log/mumble-server/mumble-server.log > /root/mumble_pw
fi

# install mediaMTX server
if [ "__INSTALL_MEDIAMTX__" = "y" ]; then
    echo "Installing MediaMTX"
	cd /tmp
	wget -q https://github.com/bluenviron/mediamtx/releases/download/v1.15.3/mediamtx_v1.15.3_linux_arm64.tar.gz
	gzip -d mediamtx_v1.15.3_linux_arm64.tar.gz
	tar -xf mediamtx_v1.15.3_linux_arm64.tar
	groupadd --system mediamtx
	useradd --system -g mediamtx -d /opt/mediamtx -s /sbin/nologin mediamtx
	mkdir /etc/mediamtx && chown mediamtx:mediamtx /etc/mediamtx
	mkdir -p /opt/mediamtx
	cp mediamtx /opt/mediamtx/
	chmod +x /opt/mediamtx/mediamtx
	cp mediamtx.yml /etc/mediamtx/

	cat <<- EOF > /etc/systemd/system/mediamtx.service
		[Unit]
		Description=MediaMTX RTSP/RTMP/WebRTC Server
		After=network.target

		[Service]
		User=mediamtx
		Group=mediamtx
		WorkingDirectory=/opt/mediamtx
		ExecStart=/opt/mediamtx/mediamtx /etc/mediamtx/mediamtx.yml
#		Restart=on-failure
#		RestartSec=5

		[Install]
		WantedBy=multi-user.target
	EOF
fi

echo "Setting radio-setup.sh to run at next reboot"
#set up the second provisioning script to run at boot
cat <<- EOF > /etc/systemd/system/radio-setup-run-once.service
	[Unit]
	Description=Run radio setup script once after reboot
	After=network-online.target multi-user.target
	Wants=network-online.target

	[Service]
	Type=oneshot
	ExecStart=/root/radio-setup.sh
	ExecStartPre=/bin/sleep 10
	RemainAfterExit=no

	[Install]
	WantedBy=multi-user.target
EOF
systemctl enable radio-setup-run-once.service


echo "Disabling old network managers"
systemctl stop dhcpcd
systemctl disable dhcpcd
systemctl stop NetworkManager
systemctl disable NetworkManager
systemctl mask NetworkManager

echo "Enabling systemd-networkd and systemd-resolved"
systemctl enable systemd-networkd
systemctl enable systemd-resolved

# Force systemd-resolved to be the DNS provider
ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf

#write out the config selections for future use
echo "mesh_key=__LAN_SAE_KEY__" > /etc/mesh.conf
echo "mesh_ssid=__LAN_SSID__" >> /etc/mesh.conf
echo "ipv4_network=__LAN_CIDR_BLOCK__"  >> /etc/mesh.conf
echo "mumble=__INSTALL_MUMBLE__" >> /etc/mesh.conf
echo "mtx=__INSTALL_MEDIAMTX__" >> /etc/mesh.conf
echo "acs=__AUTO_CHANNEL__" >> /etc/mesh.conf


reboot
